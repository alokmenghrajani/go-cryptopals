package aes

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestInitialize(t *testing.T) {
	aes := NewAes([]byte("YELLOW SUBMARINE")).(*aes)
	require.Equal(t, byte(0xc5), aes.sbox[0x07])
	require.Equal(t, byte(0x07), aes.invSbox[0xc5])

	require.Equal(t, byte(0xfc), aes.sbox[0x55])
	require.Equal(t, byte(0x55), aes.invSbox[0xfc])

	require.Equal(t, byte(0xf4), aes.sbox[0xba])
	require.Equal(t, byte(0xba), aes.invSbox[0xf4])

	require.Equal(t, byte(0x0d), aes.sbox[0xf3])
	require.Equal(t, byte(0xf3), aes.invSbox[0x0d])
}

func TestKeyExpansion(t *testing.T) {
	// From appendix A.1 of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
		0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()

	expected := []uint{
		0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c,
		0xa0fafe17, 0x88542cb1, 0x23a33939, 0x2a6c7605,
		0xf2c295f2, 0x7a96b943, 0x5935807a, 0x7359f67f,
		0x3d80477d, 0x4716fe3e, 0x1e237e44, 0x6d7a883b,
		0xef44a541, 0xa8525b7f, 0xb671253b, 0xdb0bad00,
		0xd4d1c6f8, 0x7c839d87, 0xcaf2b8bc, 0x11f915bc,
		0x6d88a37a, 0x110b3efd, 0xdbf98641, 0xca0093fd,
		0x4e54f70e, 0x5f5fc9f3, 0x84a64fb2, 0x4ea6dc4f,
		0xead27321, 0xb58dbad2, 0x312bf560, 0x7f8d292f,
		0xac7766f3, 0x19fadc21, 0x28d12941, 0x575c006e,
		0xd014f9a8, 0xc9ee2589, 0xe13f0cc8, 0xb6630ca6,
	}
	for i := 0; i < len(expected); i++ {
		require.Equal(t, expected[i], aes.expandedKey[i], fmt.Sprintf("i=%d", i))
	}
}

func TestAddRoundKey(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}
	aes.addRoundKey()

	expected := [16]byte{0x19, 0x3d, 0xe3, 0xbe, 0xa0, 0xf4, 0xe2, 0x2b, 0x9a, 0xc6, 0x8d, 0x2a, 0xe9, 0xf8, 0x48, 0x08}
	require.Equal(t, expected, aes.state)
}

func TestSubBytes(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0x19, 0x3d, 0xe3, 0xbe, 0xa0, 0xf4, 0xe2, 0x2b, 0x9a, 0xc6, 0x8d, 0x2a, 0xe9, 0xf8, 0x48, 0x08}
	aes.subBytes()

	expected := [16]byte{0xd4, 0x27, 0x11, 0xae, 0xe0, 0xbf, 0x98, 0xf1, 0xb8, 0xb4, 0x5d, 0xe5, 0x1e, 0x41, 0x52, 0x30}
	require.Equal(t, expected, aes.state)
}

func TestShiftRows(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0xd4, 0x27, 0x11, 0xae, 0xe0, 0xbf, 0x98, 0xf1, 0xb8, 0xb4, 0x5d, 0xe5, 0x1e, 0x41, 0x52, 0x30}
	aes.shiftRows()

	expected := [16]byte{0xd4, 0xbf, 0x5d, 0x30, 0xe0, 0xb4, 0x52, 0xae, 0xb8, 0x41, 0x11, 0xf1, 0x1e, 0x27, 0x98, 0xe5}
	require.Equal(t, expected, aes.state)
}

func TestMixColumns(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0xd4, 0xbf, 0x5d, 0x30, 0xe0, 0xb4, 0x52, 0xae, 0xb8, 0x41, 0x11, 0xf1, 0x1e, 0x27, 0x98, 0xe5}
	aes.mixColumns()

	expected := [16]byte{0x04, 0x66, 0x81, 0xe5, 0xe0, 0xcb, 0x19, 0x9a, 0x48, 0xf8, 0xd3, 0x7a, 0x28, 0x06, 0x26, 0x4c}
	require.Equal(t, expected, aes.state)
}

func TestEncrypt(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c})
	plaintext := []byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}
	ciphertext := make([]byte, BlockSize)
	aes.Encrypt(ciphertext, plaintext)
	expected := []byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32}
	require.Equal(t, expected, ciphertext)
}

func TestInvShiftRows(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0xd4, 0xbf, 0x5d, 0x30, 0xe0, 0xb4, 0x52, 0xae, 0xb8, 0x41, 0x11, 0xf1, 0x1e, 0x27, 0x98, 0xe5}
	aes.invShiftRows()

	expected := [16]byte{0xd4, 0x27, 0x11, 0xae, 0xe0, 0xbf, 0x98, 0xf1, 0xb8, 0xb4, 0x5d, 0xe5, 0x1e, 0x41, 0x52, 0x30}
	require.Equal(t, expected, aes.state)
}

func TestInvSubBytes(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0xd4, 0x27, 0x11, 0xae, 0xe0, 0xbf, 0x98, 0xf1, 0xb8, 0xb4, 0x5d, 0xe5, 0x1e, 0x41, 0x52, 0x30}
	aes.invSubBytes()

	expected := [16]byte{0x19, 0x3d, 0xe3, 0xbe, 0xa0, 0xf4, 0xe2, 0x2b, 0x9a, 0xc6, 0x8d, 0x2a, 0xe9, 0xf8, 0x48, 0x08}
	require.Equal(t, expected, aes.state)
}

func TestInvMixColumns(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}).(*aes)
	aes.keyExpansion()
	aes.state = [16]byte{0x04, 0x66, 0x81, 0xe5, 0xe0, 0xcb, 0x19, 0x9a, 0x48, 0xf8, 0xd3, 0x7a, 0x28, 0x06, 0x26, 0x4c}
	aes.invMixColumns()

	expected := [16]byte{0xd4, 0xbf, 0x5d, 0x30, 0xe0, 0xb4, 0x52, 0xae, 0xb8, 0x41, 0x11, 0xf1, 0x1e, 0x27, 0x98, 0xe5}
	require.Equal(t, expected, aes.state)
}

func TestDecrypt(t *testing.T) {
	// From appendix B of NIST.FIPS.197.pdf
	aes := NewAes([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c})
	plaintext := make([]byte, BlockSize)
	ciphertext := []byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32}
	aes.Decrypt(plaintext, ciphertext)
	expected := []byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}
	require.Equal(t, expected, plaintext)
}
